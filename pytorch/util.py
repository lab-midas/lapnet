import numpy as npimport torchfrom PIL import Imagefrom core import get_eval_results, arrange_predicted_flowclass obj:    def __init__(self, dict1):        self.__dict__.update(dict1)def count_parameters(model):    return sum(p.numel() for p in model.parameters() if p.requires_grad)def read_test_data_2D(name, acc, args):    path = args.data_path    data_path = f'{path}/{acc}/{name}'    data = np.load(data_path)    im1 = data['k_ref']    im2 = data['k_mov']    flow_orig = data['flow_full']    batches_cp = data['k_tapered']    return im1, im2, flow_orig, batches_cpdef read_test_data_3D(name, acc, args, direction):    path = args.data_path    dataID = f'{path}/{direction}/{acc}/{name}'    data = np.load(dataID)    k_ref = data['k_tapered']    im1 = data['k_ref']    im2 = data['k_mov']    flow_orig = data['flow_full']    k_cor = k_ref[..., 0]    k_sag = k_ref[..., 1]    k_cor = np.transpose(k_cor, (0, 3, 1, 2))    k_sag = np.transpose(k_sag, (0, 3, 1, 2))    return im1, im2, k_cor, k_sag, flow_origdef get_sample_results(model, name, acc, args, direction='coronal'):    if args.model == '2D':        im1, im2, flow_orig, batches_cp = read_test_data_2D(name, acc, args)        data = torch.from_numpy(np.transpose(batches_cp, (0, 3, 2, 1)))        flow_pixel = model(data.cuda())    elif args.model == '3D':        im1, im2, k_cor, k_sag, flow_orig = read_test_data_3D(name, acc, args, direction)        k_sag = torch.from_numpy(k_sag).cuda()        k_cor = torch.from_numpy(k_cor).cuda()        flow_pixel = model(k_cor, k_sag)        if direction == 'coronal':            flow_pixel = flow_pixel[0]        elif direction == 'sagittal':            flow_pixel = flow_pixel[1]    flow_pixel = flow_pixel.cpu().detach().numpy()    flow_pixel = np.squeeze(flow_pixel)    height, width = im1.shape    flow_final = arrange_predicted_flow(flow_pixel, args, height, width)    if not args.supervised:        flow_final = np.flip(flow_final, -1)    results = get_eval_results(im1, im2, flow_orig, flow_final)    print('EPE', results['loss_pred'])    print('EAE', results['loss_ang_pred'])    print('psnr', results['psnr'])    print('ssim', results['ssim'])    # show_results(results, name, args)    return resultsdef eval_imgs_sag(model, ckpt, args):    model.load_state_dict(        torch.load(ckpt, map_location='cuda:0')['model_state_dict'])    model.cuda()    model.evaluate_checkpoint()    name = args.ID_sag    images = {}    with torch.no_grad():        for acc in args.acc_list:            results = get_sample_results(model, name, acc, args, 'sagittal')            flow_img = Image.fromarray(results['color_flow_pred'], 'RGB')            images[str(acc)] = flow_img    flow_LAP = Image.fromarray(results['color_flow_gt'], 'RGB')    images['LAP'] = flow_LAP    return imagesdef eval_dict(model, ckpt, args):    model.load_state_dict(        torch.load(ckpt, map_location='cuda:0')['model_state_dict'])    model.cuda()    model.evaluate_checkpoint()    name = args.ID    images = {}    keyList = ['ssim', 'psnr', 'EAE', 'EPE', 'photometric_loss']    dic_acc = {str(key): 0 for key in args.acc_list}    losses = {key: dic_acc for key in keyList}    with torch.no_grad():        for acc in args.acc_list:            results = get_sample_results(model, name, acc, args)            flow_img = Image.fromarray(results['color_flow_pred'], 'RGB')            # flow_img.show()            images[str(acc)] = flow_img            img_ref = results['img_ref']            img_pred = results['mov_corr']            losses['ssim'][str(acc)] = results['psnr'].mean()            losses['psnr'][str(acc)] = results['ssim'].mean()            losses['EAE'][str(acc)] = results['loss_ang_pred'].mean()            losses['EPE'][str(acc)] = results['loss_pred'].mean            losses['photometric_loss'][str(acc)] = np.sum(np.absolute((img_pred - img_ref)))        flow_LAP = Image.fromarray(results['color_flow_gt'], 'RGB')        images['LAP'] = flow_LAP    return images, losses