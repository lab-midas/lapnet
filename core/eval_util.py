import matplotlib.pyplot as pltimport numpy as npimport timefrom .image_warp import np_warp_2Dfrom .Warp_assessment3D import warp_assessment3Dfrom .flow_util import flow_to_color_npfrom medutils.measures import psnr, ssimfrom .util import pos_generation_2Ddef pos_sliding_window(args):    height, width = args['img_size']    stride = args['stride_size']    x_dim = height + args['patch_size'] - 1    y_dim = width + args['patch_size'] - 1    intervall = [[0, x_dim - args['patch_size'] + 1],                 [0, y_dim - args['patch_size'] + 1]]    x = np.arange(intervall[0][0], intervall[0][1], stride)    y = np.arange(intervall[1][0], intervall[1][1], stride)    vx, vy = np.meshgrid(x, y)    vx = vx.reshape(vx.shape[1] * vx.shape[0])    vy = vy.reshape(vy.shape[1] * vy.shape[0])    pos = np.stack((vx, vy), axis=0)    pos = np.transpose(pos)    return posdef add_quiver(ax, u, stride=8, offset=[0, 0], scale=None):    x, y = u.shape[:2]    gridx, gridy = np.meshgrid(np.arange(0, y, stride), np.arange(0, x, stride))    gridx, gridy = gridx + offset[0], gridy + offset[1]    ax.quiver(gridx, gridy, u[0:x:stride, :, :][:, 0:y:stride, :][:, :, 0],              -u[0:x:stride, :, :][:, 0:y:stride, :][:, :, 1], color='y', scale_units='inches', scale=scale,              headwidth=5)def get_eval_results(im1, im2, flow_gt, flow_final):    flow_final = -flow_final    im1_pred = np_warp_2D(im2, flow_final)    im_error = im1 - im2    im_error_pred = im1 - im1_pred    # warped error of GT    im1_gt = np_warp_2D(im2, -flow_gt)    im1_error_gt = im1 - im1_gt    u_GT = (flow_gt[..., 0], flow_gt[..., 1])  # tuple    u_est = (-flow_final[..., 0], -flow_final[..., 1])  # tuple    OF_index = u_GT[0] != np.nan  # *  u_GT[0] >= 0    error_data_pred = warp_assessment3D(u_GT, u_est, OF_index)    size_mtx = np.shape(flow_gt[..., 0])    u_GT = (np.zeros(size_mtx, dtype=np.float32), np.zeros(size_mtx, dtype=np.float32))  # tuple    u_est = (flow_gt[..., 0], flow_gt[..., 1])  # tuple    OF_index = u_GT[0] != np.nan  # *  u_GT[0] >= 0    error_data_gt = warp_assessment3D(u_GT, u_est, OF_index)    final_loss_orig = error_data_gt['Abs_Error_mean']    final_loss = error_data_pred['Abs_Error_mean']    final_loss_orig_angel = error_data_gt['Angle_Error_Mean']    final_loss_angel = error_data_pred['Angle_Error_Mean']    color_flow_final = flow_to_color_np(-flow_final, convert_to_bgr=False)    color_flow_gt = flow_to_color_np(flow_gt, convert_to_bgr=False)    photometric_loss = np.sum(np.absolute(im_error_pred))    psnr_loss = psnr(im1_pred, im1)    ssim_loss = ssim(im1_pred, im1)    im1 = np.abs(im1)    im1 = (im1 - np.min(im1)) / (np.max(im1) - np.min(im1))    im2 = np.abs(im2)    im2 = (im2 - np.min(im2)) / (np.max(im2) - np.min(im2))    results = dict()    results['img_ref'] = im1    results['img_mov'] = im2    results['mov_corr'] = im1_pred    results['color_flow_pred'] = color_flow_final    results['color_flow_gt'] = color_flow_gt    results['err_pred'] = im_error_pred    results['err_orig'] = im_error    results['err_gt'] = im1_error_gt    results['flow_pred'] = flow_final    results['flow_gt'] = flow_gt    results['loss_pred'] = final_loss    results['loss_orig'] = final_loss_orig    results['loss_ang_pred'] = final_loss_angel    results['loss_ang_orig'] = final_loss_orig_angel    results['psnr'] = psnr_loss    results['ssim'] = ssim_loss    results['photometric_loss'] = photometric_loss    return resultsdef generate_pos_eval(args, height, width):    x_dim = height + args.patch_size - 1    y_dim = width + args.patch_size - 1    pos = pos_generation_2D(intervall=[[0, x_dim - args.patch_size + 1],                                       [0, y_dim - args.patch_size + 1]],                            stride=args.stride_size)    pos = np.transpose(pos)    return posdef arrange_predicted_flow(flow_pixel, args, height, width):    print(flow_pixel.shape)    pos = generate_pos_eval(args, height, width)    smooth_wind_size = args.smooth_wind_size    batch_size = args.batch_size    flow_raw = np.zeros((height, width, 2), dtype=np.float32)    time_start = time.time()    smooth_radius = int((smooth_wind_size - 1) / 2)    counter_mask = np.zeros((height, width, 2), dtype=np.float32)    for i in range(int(np.floor(len(pos) / batch_size)) + 1):        flow_pixel_tmp = flow_pixel[batch_size * i:batch_size * i + batch_size, :]        local_pos = pos[batch_size * i:batch_size * i + batch_size, :]        for j in range(len(local_pos)):            lower_bound_x = max(0, local_pos[j, 0] - smooth_radius)            upper_bound_x = min(height, local_pos[j, 0] + smooth_radius + 1)            lower_bound_y = max(0, local_pos[j, 1] - smooth_radius)            upper_bound_y = min(width, local_pos[j, 1] + smooth_radius + 1)            flow_raw[lower_bound_x:upper_bound_x, lower_bound_y:upper_bound_y, :] += flow_pixel_tmp[j, :2]            counter_mask[lower_bound_x:upper_bound_x, lower_bound_y:upper_bound_y, :] += 1    flow_final = flow_raw / counter_mask    return flow_finaldef plot_results(results, show=True, save_path=None):    fig, ax = plt.subplots(3, 7, figsize=(14, 14))    plt.axis('off')    ax[0][6].imshow(results[0]['color_flow_gt'])    ax[0][6].set_title('Flow LAP masked')    # add images    for i, data in enumerate(results):        ax[i][0].imshow(np.abs(data['img_ref']), cmap='gray')        ax[i][0].set_title('Ref Img')        ax[i][1].imshow(np.abs(data['img_mov']), cmap='gray')        ax[i][1].set_title('Moving Img')        ax[i][2].imshow(np.abs(data['mov_corr']), cmap='gray')        ax[i][2].set_title('Moving Corrected')        ax[i][3].imshow(np.abs(data['err_orig']), cmap='gray')        ax[i][3].set_title('Ref - Moving')        ax[i][4].imshow(np.abs(data['err_pred']), cmap='gray')        ax[i][4].set_title('Ref - Pred')        ax[i][5].imshow(data['color_flow_pred'])        ax[i][5].set_title('Flow Pred')        photo_loss = 'loss: ' + '{:.5f}'.format(np.abs(data['err_pred']).mean())        ax[i][5].text(10, 310, photo_loss, horizontalalignment='left', fontsize=12, verticalalignment='center')    for i in range(7):        for j in range(3):            ax[j][i].axis('off')            # add US_rates:    list_us = ['1x', '8x', '30x']    for i, acc in enumerate(list_us):        ax[i][0].text(-20, 120, acc, rotation=90, horizontalalignment='center', fontsize=12,                      verticalalignment='center')    if save_path:        plt.savefig(save_path, bbox_inches='tight')    if show:        plt.show()